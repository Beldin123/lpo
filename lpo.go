// 01   July  5, 2018   Initial version uploaded to github
// 02   Aug. 28, 2018   Modified lporun, added support for Coin-OR


package lpo

// lpo: Linear Programming Object
//
// This file contains the main LPO functions used to read and write MPS files,
// build and manage the model, and print the model as well as individaul components
// of the model.

import (
	"bufio"
	"encoding/xml"
	"fmt"
	"github.com/pkg/errors"
	"io"
	"math"
	"os"
	"strconv"
	"strings"
)

// InputRow is the structure for storing information about constraints in the exported
// Rows global variable.
type InputRow struct {
    Name         string    // Constraint name
    State        int       // State (-1 = locked, 0 = active, 1 = delete)
    Type         string    // Constraint type
    SecType      int       // Secondary type (0 none, > 0 some integer variation)
    RHSlo        float64   // Lower boundary for constraint
    RHSup        float64   // Upper boundary for constraint
    HasElems     []int     // List of non-zero elements in row
    GradVecLen   float64   // Length of the gradient vector
    GradVecLenSq float64   // Length of gradient vector squared
    ScaleFactor  float64   // Scale factor for constraint
}

// InputCol is the structure for storing information about variables in the exported
// Cols global variable.
type InputCol struct {
    Name        string    // Name of the variable
    State       int       // Variable state (0 = active, 1 = delete)
    Type        string    // Variable type
    BndLo       float64   // Lower bound of the variable
    BndUp       float64   // Upper bound of the variable
    HasElems    []int     // List of non-zero elements in column
    ScaleFactor float64   // Scale factor for this variable
}

// InputElem is the structure for storing information about non-zero elements
// in the exported Elems global variable.
type InputElem struct {
    InRow       int      // Index of row where element occurs
    InCol       int      // Index of column where element occurs
    Value       float64  // Value of element for that row and column
}

// The "Cplex" data types define the XML data
// structures for parsing the output generated by Cplex. They are defined to
// match the logical blocks of data contained in the output. 
//
// CplexHeader contains general information about the Cplex solution.
type CplexHeader struct {
	XMLName         xml.Name   `xml:"header"`
	ProblemName     string     `xml:"problemName,attr"`
	ObjValue        float64    `xml:"objectiveValue,attr"`
	SolTypeValue    int        `xml:"solutionTypeValue,attr"`
	SolTypeString   string     `xml:"solutionTypeString,attr"`
	SolStatusValue  int        `xml:"solutionStatusValue,attr"`
	SolStatusString string     `xml:"solutionStatusString,attr"`
	SolMethodString string     `xml:"solutionMethodString,attr"`
	PrimalFeasible  int        `xml:"primalFeasible,attr"`
	DualFeasible    int        `xml:"dualFeasible,attr"`
	SimplexItns     int        `xml:"simplexIterations,attr"`
	BarrierItns     int        `xml:"barrierIterations,attr"`
	WriteLevel      int        `xml:"writeLevel,attr"`
}

// CplexQuality contains quality statistics of the Cplex solution.
type CplexQuality struct {
	XMLName           xml.Name `xml:"quality"`
	EpRHS             float64  `xml:"epRHS,attr"`
	EpOpt             float64  `xml:"epOpt,attr"`
	MaxPrimalInfeas   float64  `xml:"maxPrimalInfeas,attr"`
	MaxDualInfeas     float64  `xml:"maxDualInfeas,attr"`
	MaxPrimalResidual float64  `xml:"maxPrimalResidual,attr"`
	MaxDualResidual   float64  `xml:"maxDualResidual,attr"`
	MaxX              float64  `xml:"maxX,attr"`
	MaxPi             float64  `xml:"maxPi,attr"`
	MaxSlack          float64  `xml:"maxSlack,attr"`
	MaxRedCost        float64  `xml:"maxRedCost,attr"`
	Kappa             float64  `xml:"kappa,attr"`
}

// CplexResCon contains the list of constraints processed by Cplex.
type CplexResCon struct {
	Name   string  `xml:"name,attr"`
	Index  int     `xml:"index,attr"`
	Status string  `xml:"status,attr"`
	Slack  float64 `xml:"slack,attr"`
	Dual   float64 `xml:"dual,attr"`
}

// CplexResVarb contains the list of variables processed by Cplex and their optimal
// values and reduced costs.
type CplexResVarb struct {
	Name        string  `xml:"name,attr"`
	Index       int     `xml:"index,attr"`
	Status      string  `xml:"status,attr"`
	Value       float64 `xml:"value,attr"`
	ReducedCost float64 `xml:"reducedCost,attr"`
}

// CplexSoln is the main structure containing the results generated by Cplex.
// It is returned by functions which generate or process the Cplex output.
type CplexSoln struct {
	XMLName    xml.Name     `xml:"CPLEXSolution"`
	Version    string       `xml:"version,attr"`
	Header     CplexHeader   
	Quality    CplexQuality   
	LinCons  []CplexResCon  `xml:"linearConstraints>constraint"`
	Varbs    []CplexResVarb `xml:"variables>variable"`
}

// Statistics contains the statistics associated with the problem being solved.
// It contains the statistics proper, and methods to get and print them.
type Statistics struct {
	NumElements  int       // Number of non-zero elements
	NumRows      int       // Number of rows, including the objective function
	NumGRows     int       // Number of "greater than" constraints
	NumLRows     int       // Number of "less than" constraints
	NumERows     int       // Number of "equal" constraints
	NumNRows     int       // Number of non-binding constraints
	NumRRows     int       // Number of constraints that cover a range
    NumIntRows   int       // Number of binding integer constraints
	NumMc0Rows   int       // Number of binding multiple choice constraints that include 0
	NumMc1Rows   int       // Number of binding multiple choice constraints
	AvgElsPerRow float64   // Average elements per constraint
	MaxElsInRow  int       // Maximum number of elements in a constraint
	TotCons      int       // Number of binding constraints
	NumCols      int       // Number of variables (columns)
	NumICols     int       // Number of variables that are integer
	NumRCols     int       // Number of variables that are real numbers
	NumBinCols   int       // Number of binary variables
	AvgElsPerCol float64   // Average number of elements per column
	MaxElsInCol  int       // Maximum number of elements in a column
	TotBnds      int       // Number of binding bounds	
}

// Global variables exported by this package.
var (
    Name    string         // Name of the problem
    ObjRow  int            // Index of objective function, should be 0 (first row)
    Plinfy  float64        // Value of positive infinity (default 1e20) 
    Featol  float64        // Feasibility tolerance (default 1e-6).
    Rows    []InputRow     // List of rows
    Cols    []InputCol     // List of columns 
    Elems   []InputElem    // List of non-zero elements 
)

//==============================================================================

// Package global variables
var objRowConst    float64          // RHS for objective function if not 0
var pausePrint     int = 50         // Limit at which printout should pause
var logLevel       int = pINFO      // Level of printed detail
var tempDirPath string = "c:/temp"  // Path for temp directory 

// Package global constants for row and column states
const (
	stateLocked = -1      // Entity must not be deleted (objective function)    
	stateActive =  0      // Entity is active and can be moved or deleted       
	stateDelete =  1      // Entity is tagged for deletion but not yet removed
)

// Package global constants defining special integer constraints in InputRow structure
const (
	conTypeNone = 0  // No secondary state
	conTypeInt  = 1  // Binding constraints that are all integer
	conTypeMc0  = 2  // Binding constraints are multiple choice but can take 0
	conTypeMc1  = 3  // Binding constraints are multiple choice	
)

// Constants which control the level of detail when printing messages.
// Everything up to and including logLevel is printed, anything above does not.
// For no output, logLevel must be set to 0.
const (
	pNONE  = 0   // Nothing is printed, use to set logLevel only
	pERR   = 1   // Error messages
	pWARN  = 2   // Warnings
	pINFO  = 3   // Information status messages (default state)
	pDEB   = 4   // Debug statements
	pTRC   = 5   // Detailed trace statements	
)

//==============================================================================
// FUNCTIONS ASSOCIATED WITH THE ENVIRONMENT
//==============================================================================

// log prints the message if msgLevel is less than or equal to logLevel, which is
// an externally-configurable package global variable.
// Format string must be provided but can be empty ("").
func log (msgLevel int, format string, a ...interface{}) {
	var msg string   // message to be printed for the given log level
		
	if msgLevel <= logLevel {
		if format != "" {
			msg = fmt.Sprintf(format, a...)
			fmt.Printf(msg)
		} else {
			fmt.Println(a...)
		}
	} 
}

//==============================================================================

// GetLogLevel returns the value (from 0 = none to 5 = detailed trace) 
// which controls the level of detail to be printed during program execution.
//
// Functions whose purpose is to print information about the model (e.g. PrintModel())
// are not affected by the value of the log level.
func GetLogLevel(level *int) error {
	*level = logLevel
	return nil	
}

//==============================================================================

// SetLogLevel sets the level of detail to be printed during program execution.
// The supported, but not enforced, range is from 0 = none to 5 = detailed trace.
func SetLogLevel(level int) error {
	logLevel = level
	return nil
}

//==============================================================================

// GetTempDirPath returns the path to the temp directory used for storing internal
// files. By default it is c:/temp.
func GetTempDirPath(dirPath *string) error {
	*dirPath = tempDirPath
	return nil
}

//==============================================================================

// SetTempDirPath sets the location of the temp directory used for storing
// internal files to the value specified. The default value is c:/temp.
func SetTempDirPath(dirPath string) error {
	tempDirPath = dirPath
	return nil
}

//==============================================================================
// GENERAL UTILITY FUNCTIONS
//==============================================================================

// InitModel initializes the global structures which store the model. In case of
// failure, an error is returned. 
func InitModel() error {

	//Initialize constraint structure.
	for i := 0; i < len(Rows); i++ {
		Rows[i].Name         = ""
		Rows[i].Type         = ""
		Rows[i].State        = stateActive
		Rows[i].SecType      = conTypeNone
		Rows[i].RHSlo        = 0.0
		Rows[i].RHSup        = 0.0
		Rows[i].HasElems     = nil
		Rows[i].GradVecLenSq = 0.0
		Rows[i].GradVecLen   = 0.0
		Rows[i].ScaleFactor  = 1.0
	}
	
	// Initialize variables structure.
	for i := 0; i < len(Cols); i++ {
		Cols[i].State       = stateActive
		Cols[i].HasElems    = nil
		Cols[i].BndLo       = 0.0
		Cols[i].BndUp       = 0.0
		Cols[i].Name        = ""
		Cols[i].Type        = ""
		Cols[i].ScaleFactor = 1.0
	}

	// Initialize non-zero elements structure.	
	for i := 0; i < len(Elems); i++ {
		Elems[i].InCol = 0
		Elems[i].InRow = 0
		Elems[i].Value = 0.0
	}

	// Initialize global variables.
	Name        = ""
	ObjRow      = -1
	objRowConst = 0.0
	Rows        = nil
	Cols        = nil
	Elems       = nil

	// If the values of Plinfy and Featol have not been set, then set them to 
	// the default values.
	if Plinfy == 0.0 {
		Plinfy = 1.0e20
	}
	if Featol == 0.0 {
		Featol = 1.0e-6
	}
	
	return nil
}

//==============================================================================

// calcGadVec calculates the gradient vector length and gradient vector length
// squated values and sets the fields to these values in each constraint of the
// exported global variable.
func calcGradVec() error {	
	var rhold float64  // holder for real numbers during processing
	var index int      // holder for array indices during processing
	
	for i := 0; i < len(Rows); i++ {
		rhold = 0.0
		for iel := 0; iel < len(Rows[i].HasElems); iel++ {
			index = Rows[i].HasElems[iel]
			rhold = rhold + Elems[index].Value * Elems[index].Value
		}
		Rows[i].GradVecLenSq = rhold
		Rows[i].GradVecLen   = math.Sqrt(rhold)		
	}	

	return nil	
}

//==============================================================================

// AdjustModel performs some post-processing operations on the model after the
// global variables defining the model have been populated. Those operations include
// calculation of the gradient vector for each constraint, setting the secondary
// type field (SecType) for each constraint in the Rows structure, and moving the
// objective function, if it exists, to be the first item of the Rows list.
// In case of failure, the function returns an error.
func AdjustModel() error {
	var ihold int  // holder for integer numbers during processing
	var index int  // holder for array indices during processing
	var err error  // error value returned by secondary functions called by this one

	if len(Rows) == 0 {
		return errors.New("List of Rows is empty")		
	}
	
	// Take the first nonbinding row as the objective function.
	// Also lock this row (State = -1) to prevent deletion in future processing.
	ihold = -1 // initial row of objective function
	for i := 0; i < len(Rows); i++ {
		if Rows[i].Type == "N" {
			ihold = i
			Rows[i].State = stateLocked
			break
		}
	}
	if ihold < 0 {
		log(pWARN, "WARNING: No objective function in model!\n")
	}
	ObjRow = ihold
	if ihold >= 0 {
		log(pINFO, "Objective function: %s\n", Rows[ihold].Name)
		if Rows[ihold].RHSlo != 0.0 || Rows[ihold].RHSup != 0.0 {
			// During processing, both bounds are set to same value (treated as "E").
			// Remember this constant term for postprocessing.
			objRowConst = Rows[ihold].RHSlo
			log(pWARN, "WARNING: Objective function includes constant %f.\n", 
				Rows[ihold].RHSlo)
		}
	} // End objective function found

	// Look for empty rows, identify the special constraint types, 
	// set the initial scale factors, and calculate the gradient vector.
	for i := 0; i < len(Rows); i++ {
		Rows[i].ScaleFactor = 1.0
		if len(Rows[i].HasElems) == 0 {
			log(pWARN, "WARNING: Row %d (%s) has no elements. Converted to nonbinding type.\n", i, Rows[i].Name)
			Rows[i].Type = "N"
			continue
		}
		// identify the three special types of constraints
		if Rows[i].Type == "N" {
			continue
		}
		isIntCon := true
		isMC0Con := true
		isMC1Con := true
		for j := 0; j < len(Rows[i].HasElems); j++ {
			index = Rows[i].HasElems[j]
			// All variables must be integer
			if Cols[Elems[index].InCol].Type != "I" {
				isIntCon = false
				isMC0Con = false
				isMC1Con = false
				break
			}
			// All variables must have a lower bound of zero and upper bound of 1
			if (Cols[Elems[index].InCol].BndLo != 0.0) || (Cols[Elems[index].InCol].BndUp != 1.0) {
				isMC0Con = false
				isMC1Con = false
			} else if Elems[index].Value != 1.0 {
				// All variables must have coefficent of 1
				isMC0Con = false
				isMC1Con = false
			}
		}
		// If some of the indicators are true, add secondary type indicator to the
		// appropriate row.
		if Rows[i].RHSup != 1.0 {
			// RHS upper bound must be 1
			isMC0Con = false
			isMC1Con = false
		}
		if isMC0Con && Rows[i].Type == "L" {
			Rows[i].SecType = conTypeMc0
			continue
		}
		if isMC1Con && Rows[i].Type == "E" {
			Rows[i].SecType = conTypeMc1
			continue
		}
		if isIntCon {
			Rows[i].SecType = conTypeInt
		}

	} // End for all Rows

	// Calculate the gradient vector length for all rows
		
	_ = calcGradVec()
	
	// Look for empty columns
	for i := 0; i < len(Cols); i++ {
		Cols[i].ScaleFactor = 1.0
		if len(Cols[i].HasElems) == 0 {
			log(pWARN, "WARNING: MPS file column %d (%s) has no elements.\n", i, Cols[i].Name)
		}
	}

	// If the objective function is not the first row, move it there.
	if ObjRow != 0 {
		log(pINFO, "Moving %s from index %d to top of list.\n", Rows[ObjRow].Name, ObjRow)
		if err = swapRows(0, ObjRow); err != nil {
			return errors.Wrap(err, "Failed to swap objective row")	
		}
		ObjRow = 0	
	}

	log(pINFO, "Successfully read %d rows and %d cols.\n", len(Rows), len(Cols))
	
	return nil
}

//==============================================================================

// snap is used when adjusting the bounds on an integer variable to snap them to 
// appropriate integer values. It takes in a floating point value and snaps it to 
// the appropriate integer value for the input bound boundType can be "L" or "U" 
// for the type of bound that is being adjusted
func snap(numIn float64, boundType string) (snapValue float64) {	
	var down float64  // closest integer value lower than number passed in
	
	down = math.Trunc(numIn)
	// Do this if the input number is close enough to integer
	if numIn-down <= Featol {
		return down
	}
	if down+1.0-numIn <= Featol {
		return down + 1.0
	}
	if boundType == "L" {
		// For a lower bound
		return down + 1.0
	} else {
		// For an upper bound
		return down
	}
	return
}

//==============================================================================

// CalcLhs takes as input the row index and list of variable values for
// that row, and returns the value of the constraint (lhs) and a status in the 
// argument list. In case of error, it returns that error as the function value.
//	The function arguments have the following meaning:
//	   rowIndex  [input]: index of row to be checked
//	   point     [input]: list of variable values for the row specified
//	   lhs      [output]: value of the lhs for the variables passed in
//	   status   [output]: 0 (normal), 1 (non-binding), 2 (error)
func CalcLhs(rowIndex int, point []float64, lhs *float64, status *int) error {
	var iel int  // index in Elems list

	*status = 2
	
	if rowIndex < 0 || rowIndex >= len(Rows) {
		return errors.Errorf("Index %d out of range", rowIndex)			
	}

	if len(point) != len(Rows[rowIndex].HasElems) {
		return errors.Errorf("CalcLhs received %d variables, expected %d", 
				len(point), len(Rows[rowIndex].HasElems))					
	}

	// Calculate the LHS value	
	*lhs    = 0	
	for i := 0; i < len(Rows[rowIndex].HasElems); i++ {
		iel  = Rows[rowIndex].HasElems[i]
		*lhs = *lhs + Elems[iel].Value * point[i]	
	}
	
	if math.IsNaN(*lhs) {
		return errors.Errorf("CalcLhs generated NaN for row %s", Rows[rowIndex].Name)					
	}

	// Looking good so far, now determine if the constraint is non-binding or "normal".

	if Rows[rowIndex].Type == "N" {
		*status = 1
	} else {
		*status = 0
	}
	
	return nil		
}

//==============================================================================

// CalcConViolation takes as input the row index and list of variable values for
// that row, and returns a number (viol) and a status in the argument list. In case
// of error, it returns that error as the function value. 
//	The function arguments have the following meaning:
//	   rowIndex  [input]: index of row to be checked
//	   point     [input]: list of variable values for the row specified
//	   viol     [output]: magnitude and sign for the violation
//	   status   [output]: 0 (not violated), 1 (violated), 2 (tight), 
//	                      3 (problem evaluating the constraint)
func CalcConViolation(rowIndex int, point []float64, viol *float64, status *int) error {
	var rowtype string   // row type of constraint being processed
	var rhold   float64  // holder for real number being processed
	var lhs     float64  // lhs value calculated for this constraint
	var err     error    // error value received from secondary functions called

	*viol   = 0.0
	*status = 3

	// Check that row index is valid.
	if rowIndex < 0 || rowIndex >= len(Rows) {
		return errors.Errorf("Row index %d out of range", rowIndex)					
	}
	
	// If this is a non-binding constraint, look no further, but don't flag
	// as an error.
	if Rows[rowIndex].Type == "N" {
		*status = 0
		return nil
	}
	
	// Calculate the LHS and return if any errors are detected.	
	if err = CalcLhs(rowIndex, point, &lhs, status); err != nil {
		return errors.Wrap(err, "CalcConViolation failed")
	}

	rowtype = Rows[rowIndex].Type

	// Need to check lower bound for applicable row types.	
	if rowtype == "G" || rowtype == "E" || rowtype == "R" {
		rhold = Rows[rowIndex].RHSlo - lhs

		if rhold > Featol {
			// Constraint is violated by more than the tolerance.
			*status = 1
			*viol   = rhold
			return nil
		}
		if math.Abs(rhold) <= Featol {
			// Constraint is tight.
			*status = 2
			*viol   = 0.0
			return nil
		}
	} // End if checking lower bound.
	
	// Need to check upper bound for applicable row types.
	if rowtype == "L" || rowtype == "E" || rowtype == "R" {
		rhold = Rows[rowIndex].RHSup - lhs
		if rhold < -Featol {
			// Constraint is violated by more than the tolerance.
			*status = 1
			*viol   = rhold
			return nil
		}
		if math.Abs(rhold) <= Featol {
			// Constraint is tight
			*status = 2
			*viol   = 0.0
			return nil
		}
	}

	// Constraint is satisfied.	
	*status = 0
	*viol   = 0.0
	
	return nil
}

//==============================================================================

// TODO: This function is not working and needs to be looked at and fixed.
//
// scaleCols performs equilibriation scaling on the columns by dividing through 
// by the largest element. Only a single pass is done. Changes are made to the 
// global Cols data structure. 
// In case of failure, it returns an error. 
func scaleCols() error {
	var maxValue  float64  // maximum coefficient value for column
	var minValue  float64  // minimum coefficient value
	var gMaxValue float64  // global maximum coefficient value
	var rhold     float64  // holder for real number during processing
	var iel       int      // index of item in elements list

	log(pINFO, "Scaling columns.\n")


	gMaxValue = 0.0
	minValue  = Plinfy
	
	// Process all columns in the model
	for i := 0; i < len(Cols); i++ {

		maxValue = 0.0
				
		// Find the largest absolute value coefficient for this column
		for j := 0; j < len(Cols[i].HasElems); j++ {

			iel   = Cols[i].HasElems[j]
			rhold = math.Abs(Elems[iel].Value)
			
			if rhold > maxValue {
				maxValue = rhold
			}
						
			if rhold < minValue {
				minValue = rhold
			}
		} // End for searching for largest absolute value coefficient

		// We will divide by maxValue, so if it is not needed (1) or not safe (0),
		// skip this column.

		if maxValue > gMaxValue {
			gMaxValue = maxValue
		}
		
		if  maxValue == 1.0 || maxValue <= 0.0 {
			continue
		}

		// Update the scale factor for this column and update the bounds if needed.

		Cols[i].ScaleFactor = Cols[i].ScaleFactor * maxValue

		if Cols[i].BndLo > -Plinfy && Cols[i].BndLo < Plinfy {
			//fmt.Printf("Before: i = %d, BndLo = %f, maxVal = %f\n", i, Cols[i].BndLo, maxValue)
			Cols[i].BndLo = Cols[i].BndLo / maxValue
			//fmt.Printf("After:  i = %d, BndLo = %f, maxVal = %f\n", i, Cols[i].BndLo, maxValue)
		}
		
		if Cols[i].BndUp > -Plinfy && Cols[i].BndUp < Plinfy {
			//fmt.Printf("Before: i = %d, BndUp = %f, maxVal = %f\n", i, Cols[i].BndUp, maxValue)
			Cols[i].BndUp = Cols[i].BndUp / maxValue
			//fmt.Printf("After:  i = %d, BndUp = %f, maxVal = %f\n", i, Cols[i].BndUp, maxValue)
		}
		
		// Divide all coefficients by the maximum value.

		for j := 0; j < len(Cols[i].HasElems); j++ {
			iel = Cols[i].HasElems[j]
			Elems[iel].Value = Elems[iel].Value / maxValue
		}		
				
	} // End for all columns

	// Recalculate the gradient vector for all rows.

	_ = calcGradVec()

	log(pINFO, "Lowest column scale factor %f, highest %f.\n", minValue, gMaxValue)

	return nil
}

//==============================================================================

// ScaleRows performs equilibriation scaling on the rows by dividing through 
// by the largest element. Only a single pass is done. Changes are made to the 
// global Rows data structure. 
// In case of failure, it returns an error. 
func ScaleRows() error {
	var maxValue float64  // maximum coefficient value for row
	var rhold    float64  // holder for real number during processing
	var iel      int      // index of item in elements list
	
	
	for i := 0; i < len(Rows); i++ {

		// Find the largest absolute value coefficient for this row		
		maxValue = 0.0		
		for j := 0; j < len(Rows[i].HasElems); j++ {
			
			iel   = Rows[i].HasElems[j]
			rhold = math.Abs(Elems[iel].Value)
			
			if rhold > maxValue {
				maxValue = rhold
			}
			
		} // End for looking for largest absolute value coefficient

		// We will divide by maxValue, so if it is not needed (1) or not safe (0),
		// skip this row.

		if  maxValue == 1.0 || maxValue <= 0.0 {
			continue
		}

		// Update the scale factor and, if needed, RHS values for this row.
		
		Rows[i].ScaleFactor = Rows[i].ScaleFactor * maxValue

		if Rows[i].RHSlo > -Plinfy && Rows[i].RHSlo < Plinfy {
			Rows[i].RHSlo = Rows[i].RHSlo / maxValue
		}

		if Rows[i].RHSup > -Plinfy && Rows[i].RHSup < Plinfy {
			Rows[i].RHSup = Rows[i].RHSup / maxValue
		}

		// Divide each coefficient for this row by max value, and remember
		// the total sum so we can update the gradient vector length.

		rhold = 0.0
		
		for j := 0; j < len(Rows[i].HasElems); j++ {
			iel = Rows[i].HasElems[j]
			Elems[iel].Value = Elems[iel].Value / maxValue
			rhold += Elems[iel].Value * Elems[iel].Value
		}
		
		Rows[i].GradVecLenSq = rhold
		Rows[i].GradVecLen   = math.Sqrt(rhold)
				
	} // End for all rows

	return nil	
}

//==============================================================================

// TightenBounds tightens the bounds on the variables by executing multiple passes 
// until no more tightenings can be made. Function accepts the maximum number of
// of passes (maxRounds) to be performed, and returns the number of rounds that were
// actually performed (numRounds). In case of failure, it also returns an error.
func TightenBounds(maxRounds int, numRounds *int) error {
	var colChanged     []bool  // list of columns where adjustments made in last round
	var checkCon       []bool  // list of constraints where variables changed last time
	var anotherRound     bool  // true if there is another round to do
	var colMin      []float64  // minimum value of column in current round
	var colMax      []float64  // maximum value of column in current round
	var tempLo        float64  // temporarily holds adjusted value of lower bound
	var tempUp        float64  // temporarily holds adjusted value of upper bound
	var rhold, rhold1 float64  // local holders for real values
	var icol              int  // holds column index at various points
	var index             int  // temporarily holds index of various arrays being processed
	var numAdjustments    int  // number of adjustments made during pass
	var totAdjustments    int  // cumulative total of all adjustments made
	var numElInRow        int  // number of elements in current row
	var rowType        string  // holds the value of the row type since it's checked a few times

	checkCon = make([]bool, len(Rows))
	colChanged = make([]bool, len(Cols))
	*numRounds = 0

	// Initially we check all rows and all columns
	for icon := 0; icon < len(Rows); icon++ {
		checkCon[icon] = true
	}
	for ivar := 0; ivar < len(Cols); ivar++ {
		colChanged[ivar] = false
	}
	anotherRound = true

	// continue iterating as long as even one bound was tightened last time
	for anotherRound {
		if *numRounds >= maxRounds {
			return nil
		}
		*numRounds++
		
		log(pDEB, "===== Round %d =====\n", *numRounds)
		numAdjustments = 0
		anotherRound = false
		// Check the indicated rows
		for icon := 0; icon < len(Rows); icon++ {
			rowType    = Rows[icon].Type
			numElInRow = len(Rows[icon].HasElems)
			if (rowType == "N") || !checkCon[icon] {
				continue
			}
			// Find the column maxes and mins in this row
			colMin = nil
			colMax = nil
			colMin = make([]float64, numElInRow)
			colMax = make([]float64, numElInRow)
			for i := 0; i < numElInRow; i++ {
				// Get the coefficient times lower and upper bounds on variables.
				//icol = Rows[icon].ElCol[i]
				//rhold = Rows[icon].ElVal[i] * Cols[icol].BndLo
				//rhold1 = Rows[icon].ElVal[i] * Cols[icol].BndUp
				
				index  = Rows[icon].HasElems[i]
				rhold  = Elems[index].Value * Cols[Elems[index].InCol].BndLo
				rhold1 = Elems[index].Value * Cols[Elems[index].InCol].BndUp 
				
				if rhold > rhold1 {
					colMax[i] = rhold
					colMin[i] = rhold1
				} else {
					colMax[i] = rhold1
					colMin[i] = rhold
				}
			}

			if (rowType == "L") || (rowType == "E") || (rowType == "R") {
				// Check each column individually
				for i := 0; i < numElInRow; i++ {
					// icol = Rows[icon].ElCol[i]
					index = Rows[icon].HasElems[i]
					icol  = Elems[index].InCol
					rhold = 0.0
					for j := 0; j < numElInRow; j++ {
						if j == i {
							continue
						}
						rhold = rhold + colMin[j]
					}
					if rhold+colMax[i] > Rows[icon].RHSup+Featol {
						// Adjust the appropriate bound based on sign of the coefficient
						// if Rows[icon].ElVal[i] > 0.0 {
							
						if Elems[index].Value > 0.0 {	
							// possibly adjust upper bound
							// tempUp = (Rows[icon].RHSup - rhold) / Rows[icon].ElVal[i]
							tempUp = (Rows[icon].RHSup - rhold) / Elems[index].Value
							if tempUp < Cols[icol].BndUp-Featol {
								colChanged[icol] = true
								anotherRound = true
								numAdjustments++
								Cols[icol].BndUp = tempUp
								if Cols[icol].Type == "I" {
									Cols[icol].BndUp = snap(Cols[icol].BndUp, "U")
								}
								log(pTRC, "Upper bound on variable %d %s reduced to %f.\n", icol, Cols[icol].Name, Cols[icol].BndUp)
							}
						} else {
							// possibly adjust lower bound
							// tempLo = (Rows[icon].RHSup - rhold) / Rows[icon].ElVal[i]
							tempLo = (Rows[icon].RHSup - rhold) / Elems[index].Value
							if tempLo > Cols[icol].BndLo+Featol {
								colChanged[icol] = true
								anotherRound = true
								numAdjustments++
								Cols[icol].BndLo = tempLo
								if Cols[icol].Type == "I" {
									Cols[icol].BndLo = snap(Cols[icol].BndLo, "L")
								}
								log(pTRC, "Lower bound on variable %d %s increased to %f.\n", icol, Cols[icol].Name, Cols[icol].BndLo)
							}
						} // end else lower bound may need adjusting
						if Cols[icol].BndLo > Cols[icol].BndUp {
							log(pERR, "ERROR: Infeasible, bounds reversal on %d - %s.\n", icol, Cols[icol].Name)
							return errors.Errorf("TightenBounds infeasible, bounds reversal on %s", Cols[icol].Name)
						}
					} // end if upper row bound needs adjusting
				} // end for all elements in row
			} // end if L, E, R row

			if (rowType == "G") || (rowType == "E") || (rowType == "R") {
				// Check each column individually
				for i := 0; i < numElInRow; i++ {
					// icol = Rows[icon].ElCol[i]
					index = Rows[icon].HasElems[i]
					icol  = Elems[index].InCol
					rhold = 0.0
					for j := 0; j < numElInRow; j++ {
						if j == i {
							continue
						}
						rhold = rhold + colMax[j]
					}
					if rhold+colMin[i] < Rows[icon].RHSlo-Featol {
						// Adjust the appropriate bound based on sign of the coefficient
						// if Rows[icon].ElVal[i] > 0.0 {
						
						if Elems[index].Value > 0.0 {
													
							// Lower bound on this column is tightened
							tempLo = (Rows[icon].RHSlo - rhold) / Elems[index].Value
							if tempLo > Cols[icol].BndLo+Featol {
								colChanged[icol] = true
								anotherRound = true
								numAdjustments++
								Cols[icol].BndLo = tempLo
								if Cols[icol].Type == "I" {
									Cols[icol].BndLo = snap(Cols[icol].BndLo, "L")
								}
								log(pTRC, "Lower bound on variable %d %s increased to %f.\n", icol, Cols[icol].Name, Cols[icol].BndLo)
							}
						} else {
							// Upper bound on this column is tightened
							tempUp = (Rows[icon].RHSlo - rhold) / Elems[index].Value
							if tempUp < Cols[icol].BndUp-Featol {
								colChanged[icol] = true
								anotherRound = true
								numAdjustments++
								Cols[icol].BndUp = tempUp
								if Cols[icol].Type == "I" {
									Cols[icol].BndUp = snap(Cols[icol].BndUp, "U")
								}
								log(pTRC, "Upper bound on variable %d %s reduced to %f.\n", icol, Cols[icol].Name, Cols[icol].BndUp)
							}
						} // end else upper bound on column is tightened
						if Cols[icol].BndLo > Cols[icol].BndUp {
							log(pERR, "ERROR: Infeasible, bounds reversal on %d - %s.\n", icol, Cols[icol].Name)
							return errors.Errorf("TightenBounds infeasible, bounds reversal on %s", Cols[icol].Name)
						} // end if coefficient is positive
					} // end if row lower bound needs adjusting
				} // end for all elements in row
			} // end if G, E, R row

		} // end of examination of rows

		if anotherRound {
			for i := 0; i < len(Rows); i++ {
				checkCon[i] = false
			}
			for i := 0; i < len(Cols); i++ {
				if colChanged[i] {
					for j := 0; j < len(Cols[i].HasElems); j++ {
						index = Cols[i].HasElems[j]
						//checkCon[Cols[i].InRow[j]] = true
						checkCon[Elems[index].InRow] = true
					}
				}
				colChanged[i] = false
			}
		}
		log(pDEB, "%d bound adjustments made.\n", numAdjustments)
		totAdjustments = totAdjustments + numAdjustments
	}
	numAlwaysSat := 0
	//check for constraints that are now always satisfied and change their type to "N"
	for i := 0; i < len(Rows); i++ {
		if Rows[i].Type == "N" {
			continue
		}
		//calculate lowest possible LHS value
		tempLo = 0.0
		for j := 0; j < len(Rows[i].HasElems); j++ {
			index = Rows[i].HasElems[j]
			if Elems[index].Value < 0.0 {
				//tempLo = tempLo + Rows[i].ElVal[j]*Cols[Rows[i].ElCol[j]].BndUp
				tempLo = tempLo + Elems[index].Value * Cols[Elems[index].InCol].BndUp
			} else {
				//tempLo = tempLo + Rows[i].ElVal[j]*Cols[Rows[i].ElCol[j]].BndLo
				tempLo = tempLo + Elems[index].Value * Cols[Elems[index].InCol].BndLo
			}
		}
		if Rows[i].Type == "G" {
			if tempLo >= Rows[i].RHSlo-Featol {
				//constraint is always satisfied
				Rows[i].Type = "N"
				numAlwaysSat++
			}
			continue
		}
		//calculate largest possible LHS value
		tempUp = 0.0
		for j := 0; j < len(Rows[i].HasElems); j++ {
			index = Rows[i].HasElems[j]
			if Elems[index].Value < 0.0 {
				//tempUp = tempUp + Rows[i].ElVal[j]*Cols[Rows[i].ElCol[j]].BndLo
				tempUp = tempUp + Elems[index].Value * Cols[Elems[index].InCol].BndLo
			} else {
				//tempUp = tempUp + Rows[i].ElVal[j]*Cols[Rows[i].ElCol[j]].BndUp
				tempUp = tempUp + Elems[index].Value * Cols[Elems[index].InCol].BndUp
			}
		}
		if Rows[i].Type == "L" {
			if tempUp <= Rows[i].RHSup+Featol {
				//constraint is always satisfied, mark it for deletion
				Rows[i].Type = "N"
				numAlwaysSat++
			}
			continue
		}
		if (tempLo >= Rows[i].RHSlo-Featol) && (tempUp <= Rows[i].RHSup+Featol) {
			//constraint is always satisfied
			numAlwaysSat++
		}
	}
	
	log(pINFO, "TightenBounds made %d adjustments, %d constraints always satisfied.\n", 
		totAdjustments, numAlwaysSat)

	// while looking over the adjusted columns, make sure bounds on integer variables are appropriately rounded
	// ***better: do that when bounds adjusted so infeasibility detected.

	return nil
}

//==============================================================================
// STATISTICS AND PRINT FUNCTIONS
//==============================================================================

// GetStatistics sets the values of the Statistics structure to the values
// currently present in the model and returns them in the stats parameter.
// In case of failure, function returns an error.
func GetStatistics(stats *Statistics) error {
	var rhold float64  // temporary holder for real numbers

	// Function does not check if Rows or Cols lists are empty even though
	// subsequent division by 0 could result in NaN values returned in the
	// average elems/row, elems/col, and density parameters.
	
	stats.NumRows     = len(Rows)
	stats.NumCols     = len(Cols)
	stats.NumElements = len(Elems)
	
	// NumRows is as reported in MPS. TotCons is number of binding row bounds.
	stats.NumGRows     = 0
	stats.NumLRows     = 0
	stats.NumERows     = 0
	stats.NumNRows     = 0
	stats.NumRRows     = 0
	stats.NumIntRows   = 0
	stats.NumMc0Rows   = 0
	stats.NumMc1Rows   = 0
	stats.AvgElsPerRow = 0
	stats.MaxElsInRow  = 0
	stats.TotCons      = 0
	for i := 0; i < len(Rows); i++ {

		// Increment the secondary type counters, which are simple.
		
		switch Rows[i].SecType {
		case conTypeInt:
			stats.NumIntRows++
			
		case conTypeMc0:
			stats.NumMc0Rows++
			
		case conTypeMc1:
			stats.NumMc1Rows++
		}
		
		// Increment the primary type counters which are more complex.		
		switch Rows[i].Type {
		case "G":
			stats.NumGRows++
			if Rows[i].RHSlo > -Plinfy {
				stats.TotCons++
			}
		case "L":
			stats.NumLRows++
			if Rows[i].RHSup < Plinfy {
				stats.TotCons++
			}
		case "E":
			stats.NumERows++
			stats.TotCons++
		case "R":
			stats.NumRRows++
			// Check that range hasn't been reversed
			// TODO: Should this function be doing this? If still needed, move
			// somewhere else.
			if Rows[i].RHSlo > Rows[i].RHSup {
				// row bounds have been reversed, so switch them back
				rhold = Rows[i].RHSlo
				Rows[i].RHSlo = Rows[i].RHSup
				Rows[i].RHSup = rhold
				log(pWARN, "Bounds on row %s were reversed. Correcting by swapping.\n", Rows[i].Name)
			}
			if Rows[i].RHSup-Rows[i].RHSlo <= Featol {
				// The range is actually an equality
				stats.NumRRows = stats.NumRRows - 1
				stats.NumERows = stats.NumERows + 1
				stats.TotCons++
				Rows[i].Type = "E"
			} else {
				if Rows[i].RHSlo > -Plinfy {
					stats.TotCons++
				}
				if Rows[i].RHSup < Plinfy {
					stats.TotCons++
				}
			}
		case "N":
			stats.NumNRows++
		}
		if len(Rows[i].HasElems) > stats.MaxElsInRow {
			stats.MaxElsInRow = len(Rows[i].HasElems)
		}
	}
	stats.AvgElsPerRow = float64(stats.NumElements) / float64(len(Rows))

	// Look at columns.
	stats.NumICols     = 0
	stats.NumBinCols   = 0
	stats.NumRCols     = 0
	stats.AvgElsPerCol = 0
	stats.MaxElsInCol  = 0
	stats.TotBnds = 0
	for i := 0; i < len(Cols); i++ {
		switch Cols[i].Type {
		case "R":
			stats.NumRCols++
		case "I":
			stats.NumICols++
			if (Cols[i].BndLo == 0.0) && (Cols[i].BndUp == 1.0) {
				stats.NumBinCols++
			}
		}
		if len(Cols[i].HasElems) > stats.MaxElsInCol {
			stats.MaxElsInCol = len(Cols[i].HasElems)
		}
		// Count the number of actual bounds and switch any reversed bounds.
		if Cols[i].BndLo > Cols[i].BndUp {
			// Bounds are reversed, so switch them back.
			rhold = Cols[i].BndLo
			Cols[i].BndLo = Cols[i].BndUp
			Cols[i].BndUp = rhold
			log(pWARN, "Bounds on variable %s were reversed. Correcting by swapping.\n", Cols[i].Name)
		}
		if Cols[i].BndUp-Cols[i].BndLo <= Featol {
			// Variable is fixed.
			stats.TotBnds++
		} else {
			if Cols[i].BndLo > -Plinfy {
				stats.TotBnds++
			}
			if Cols[i].BndUp < Plinfy {
				stats.TotBnds++
			}
		}
	}
	
	stats.AvgElsPerCol = float64(stats.NumElements) / float64(len(Cols))
	return nil
}

//==============================================================================


// PrintStatistics prints the values of the model passed to the function via
// the stats parameter.
// In case of failure, function returns an error.
func PrintStatistics(stats Statistics) error {
	
	fmt.Printf("\nPROBLEM NAME: %s\n\n",              Name)
	fmt.Printf("%d NONZERO ELEMENTS\n",               stats.NumElements)
	fmt.Printf("%10f average elements per row\n",     stats.AvgElsPerRow)
	fmt.Printf("%10f average elements per column\n",  stats.AvgElsPerCol)
	fmt.Printf("%10f density\n", float64(stats.NumElements)/float64(stats.NumRows*stats.NumCols))
	fmt.Printf("%10d maximum elements in a row\n",    stats.MaxElsInRow)
	fmt.Printf("%10d maximum elements in a column\n", stats.MaxElsInCol)
	fmt.Printf("%d ROWS IN TOTAL\n",                  stats.NumRows)
	fmt.Printf("%d Binding row bounds (equalities count as 1)\n", stats.TotCons)
	fmt.Printf("%10d GT rows\n",                      stats.NumGRows)
	fmt.Printf("%10d LT rows\n",                      stats.NumLRows)
	fmt.Printf("%10d range rows\n",                   stats.NumRRows)
	fmt.Printf("%10d equality rows\n",                stats.NumERows)
	fmt.Printf("%10d nonbinding rows\n",              stats.NumNRows)
	if stats.NumNRows > 0 {
		fmt.Printf("  %d nonzeroes in objective\n", len(Rows[ObjRow].HasElems))
	}
	fmt.Printf("   SPECIAL CONSTRAINTS:\n", )
	fmt.Printf("%10d all-integer\n",                                   stats.NumIntRows)
	fmt.Printf("%10d multiple choice type 0 (sum of binaries <= 1)\n", stats.NumMc0Rows)
	fmt.Printf("%10d multiple choice type 1 (sum of binaries = 1)\n",  stats.NumMc1Rows)
	fmt.Printf("%d COLUMNS IN TOTAL\n",                                stats.NumCols)
	fmt.Printf("%d Binding column bounds (equalities count as 1)\n",   stats.TotBnds)
	fmt.Printf("%10d real-valued columns\n",                           stats.NumRCols)
	fmt.Printf("%10d integer columns\n",                               stats.NumICols)
	fmt.Printf("%10d of the integer columns are binary",               stats.NumBinCols)
	
	fmt.Printf("\n")
	
	return nil
}

//==============================================================================

// PrintRhs prints the constraint name, type, and RHS bounds for all constraints
// obtained from the global Rows data structure. It is suitable for small models
// only. In case of failure, the function returns an error.
func PrintRhs() error {
	var userInput string  // holder for user input when printing is paused
	var counter   int     // counter tracking how many lines were printed
		
	fmt.Printf("\nRHS values for model %s are:\n\n", Name)

	fmt.Printf("%s) %4s %15s %15s %15s\n", "Index", "Type", "Row Name",
				"Lower Bound", "Upper Bound")

	for i := 0; i < len(Rows); i++ {
		fmt.Printf("%5d) %4s %15s %15e %15e\n", i, Rows[i].Type, Rows[i].Name,
			  		Rows[i].RHSlo, Rows[i].RHSup)

		counter++
		if counter == pausePrint {
			counter = 0
			fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
			fmt.Scanln(&userInput)
			if userInput != "" {
				break 
			} // End if paused
		} // End if pause required
	} // End for all rows
	
	return nil
}

//==============================================================================

// PrintCol prints the rows in which a column occurs. The column is specified
// in the global Cols data structure by the index passed to the function.
// In case of failure, the function returns an error.
func PrintCol(index int) error {
	var rIndex      int   // holder for row index
	var coef    float64   // holder for coefficient value
	
	if index < 0 || index >= len(Cols) {
		return errors.Errorf("Index %d out of range in PrintCol", index)	
	}

	fmt.Printf("Variable name: %s\n", Cols[index].Name)
	fmt.Printf("Type = %s, lower bound = %e, upper bound = %e\n\n",
		Cols[index].Type, Cols[index].BndLo, Cols[index].BndUp)
				
	fmt.Printf("%s) %15s %15s %4s %15s  to  %15s\n", "Index", "Row Name", "Coefficient",
				"Type", "Lower Bound", "Upper Bound")
			
	for i := 0; i < len(Cols[index].HasElems); i++ {
		
		rIndex = Elems[Cols[index].HasElems[i]].InRow
		coef   = Elems[Cols[index].HasElems[i]].Value
		
		fmt.Printf("%5d) %15s %15e %4s %15e  to  %15e\n", rIndex, Rows[rIndex].Name,
			coef, Rows[rIndex].Type, Rows[rIndex].RHSlo, Rows[rIndex].RHSup)
	}

	return nil	
}

//==============================================================================

// PrintRow prints a row in equation format. The row to be printed is specified
// in the global Rows data structure by the index passed to the function.
// In case of failure, the function returns an error.
func PrintRow(index int) error {
	var line string    // holder for the line to be printed as it is constructed
	var iCol int       // index of the column being processed
	var coef float64   // value of the coefficient being processed

	if index < 0 || index >= len(Rows) {
		return errors.Errorf("Index %d out of range in PrintRow", index)	
	}
	
	line = fmt.Sprintf("%4d) %8s: ", index, Rows[index].Name)
	
	if len(Rows[index].HasElems) >= 0 {
		// Construct the first coef * variable pair.
		iCol = Elems[Rows[index].HasElems[0]].InCol
		coef = Elems[Rows[index].HasElems[0]].Value

		line = line + " " + strconv.FormatFloat(coef, 'G', 6, 64) + "*" + Cols[iCol].Name	

		for i := 1; i < len(Rows[index].HasElems); i++ {
			// Append additional pairs after setting the sign to + or -.
			iCol = Elems[Rows[index].HasElems[i]].InCol
			coef = Elems[Rows[index].HasElems[i]].Value
			
			if coef < 0.0 {
				line = line + " - " + strconv.FormatFloat(-coef, 'G', 6, 64) + "*" + Cols[iCol].Name
			} else {
				line = line + " + " + strconv.FormatFloat(coef, 'G', 6, 64) + "*" + Cols[iCol].Name				
			}	
			
		} // End for all coefficients in row
	} // End if coefficients are present
	
	switch Rows[index].Type {
	case "L":
		line = line + " < " + strconv.FormatFloat(Rows[index].RHSup, 'G', 6, 64)
	case "G":
		line = line + " > " + strconv.FormatFloat(Rows[index].RHSlo, 'G', 6, 64)
	case "E":
		line = line + " = " + strconv.FormatFloat(Rows[index].RHSlo, 'G', 6, 64)
	case "N":
		line = line + " nonbinding"
	case "R":
		line = line + " > " + strconv.FormatFloat(Rows[index].RHSlo, 'G', 6, 64) + " and < " + strconv.FormatFloat(Rows[index].RHSup, 'G', 6, 64)

	} // end switch
	
	fmt.Println(line)
	
	return nil
}

//==============================================================================

// PrintModel prints the model in equation format. It is suitable for small 
// models only. The function uses global Rows and Cols data structures, accepts no
// arguments. In case of failure, function returns an error.
func PrintModel() error {
	var rowMax, rowMin float64  // max. and min. row scale values
	var colMax, colMin float64  // max. and min. column scale values
	var err            error    // error received from secondary functions called
	var counter        int      // counter for pausing printing
	var userInput      string   // string read during print pause

	// Get the maximum and minimu row and column scale factors.

	rowMax = 0.0
	colMax = 0.0
	rowMin = Plinfy
	colMin = Plinfy
	
	for i := 0; i < len(Rows); i++ {
		if Rows[i].ScaleFactor > rowMax {
			rowMax = Rows[i].ScaleFactor
		}
		if Rows[i].ScaleFactor < rowMin {
			rowMin = Rows[i].ScaleFactor
		}
	}	

	for i := 0; i < len(Cols); i++ {
		if Cols[i].ScaleFactor > colMax {
			colMax = Cols[i].ScaleFactor
		}
		if Cols[i].ScaleFactor < colMin {
			colMin = Cols[i].ScaleFactor
		}
	}	

	
	// Print the model name and scale factors if applied.
			
	fmt.Printf("\nMODEL: %s\n", Name)
	
	if rowMax != 1 || rowMin != 1 {
		fmt.Printf("Rows scaled: Max = %e, Min = %e\n", rowMax, rowMin)
	}	

	if colMax != 1 || colMin != 1 {
		fmt.Printf("Cols scaled: Max = %e, Min = %e\n", colMax, colMin)		
	}
	
	fmt.Printf("\nVARIABLES:\n")
	fmt.Printf("%5s %4s %13s %13s %13s\n", "Index", "Type", "Name", "Lower bound", "Upper bound")
	counter = 0
	for i := 0; i < len(Cols); i++ {
		fmt.Printf("%4d) %4s %13s %13e %13e\n", i, Cols[i].Type,
			Cols[i].Name, Cols[i].BndLo, Cols[i].BndUp)

		counter++
		if counter == pausePrint {
			counter = 0
			fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
			fmt.Scanln(&userInput)
			if userInput != "" {
				break 
			}
		} // End if pause required

	} // End for printing variables
	
	fmt.Printf("\nMINIMIZE OBJECTIVE:\n")
	if err = PrintRow(ObjRow); err != nil {
		return errors.Wrap(err, "PrintModel failed")
	}

	fmt.Printf("\nCONSTRAINTS:\n")
	counter   = 0
	userInput = ""
	for i := 0; i < len(Rows); i++ {
		// Ignore objective function already printed, and print the remaining rows.
		if i == ObjRow {
			continue
		}
		
		if err = PrintRow(i); err != nil {
			return errors.Wrap(err, "PrintModel failed")
		}

		counter++
		if counter == pausePrint {
			counter = 0
			fmt.Printf("\nPAUSED... <CR> continue, any key to quit: ")
			fmt.Scanln(&userInput)
			if userInput != "" {
				break 
			}
		} // End if pause required
				
	}
	return nil
}


//==============================================================================
// MPS FILE HANDLING FUNCTIONS
//==============================================================================

// ReadMpsFile reads a standard MPS data file and transfers the information into
// internal data structures.
// The function reads only the first bounds set and first RHS set. Ranges and
// binary variables are not supported by lpo at this time.
//
// The data values should be different than keywords. However
// the MPS reader can handle a RHS set called "rhs" and a BOUNDS
// set called "bounds" (or variations of those in upper or lower
// case). This avoids difficulties in reading, for example, the MIPLIB models,
// which routinely name the RHS sets "rhs".
//
// This is a free-form reader that does not require that the keywords
// or values appear in specific columns as in the original MPS
// file format. It looks for contiguous blocks of text called
// "tokens". Because of this, names cannot have blanks in them:
// a name like "con 12" will be read as two tokens ("con" and "12").
//
// Input is the full path to the file being read. The model is stored in global
// Rows and Cols data structures. If failure occurs, function returns an error.
func ReadMpsFile(fileName string) error {
	var numTokens          int  // number of tokens in line being processed
	var ihold              int  // local holder for integer values
	var numCols            int  // number of columns in model
	var mpsLineNum         int  // line number of MPS file being read
	var readState      int = 0  // data type in MPS file being processed
	var numRhs         int = 0  // counter of how many RHS values were found
	var numRanges      int = 0  // counter of how many RANGES entries in file
	var numBoundSets   int = 0  // number of BOUNDS entries in file
	var found             bool  // true if item sought has been found
	var markAsInt bool = false  // true if variable being processed is an integer
	var tempRow       InputRow  // temporary holder for rows structure
	var tempCol       InputCol  // temporary holder for cols structure
	var tempElem     InputElem  // temporary holder for elems structure
	var lastColName     string  // variable controlling switch to processing new column
	var rhsName         string  // name of RHS entry in file 
	var rangeName       string  // name of RANGES entry in file 
	var boundSetName    string  // name of BOUNDS entry in file
	var err              error  // error value received from secondary function 
	var rhold, realhold, realhold1 float64 //local holders for float64 values

	// Make the row and column maps.
	var rowMap map[string]int
	var colMap map[string]int
	rowMap = make(map[string]int)
	colMap = make(map[string]int)
	
	// Check that the input file exists and open it for reading.
	mpsFile, err := os.Open(fileName)
	if err != nil {
		log(pERR, "ERROR: Problem opening the MPS file %s.\n", fileName)
		return errors.Wrap(err, "Open MPS file failed")
	}

	log(pINFO, "\nReading MPS file %s.\n", fileName)
	defer mpsFile.Close()
	mpsReader := bufio.NewReader(mpsFile)

	// Initialize the global variables in the model.
	_ = InitModel()
		
	// In case the Objective Row has a constant term, initialize it as well
	objRowConst = 0.0

	// Create the token which will be used when reading the file.
	token := make([]string, 1)

	// The main file reading loop terminated when reaching eof -----------------

	mpsLineNum  = 0
	lastColName = ""

	for {

		// Read each line of the file until eof is reached. If a read error is 
		// detected, return that error and line number where found.
		mpsLineNum++
		curLine, err := mpsReader.ReadString('\n')

		if err == io.EOF {
			break
		}
		if err != nil {
			log(pERR, "ERROR: Problem reading line %d.\n", mpsLineNum)
			return errors.Errorf("Problem reading line %d", mpsLineNum)
		}

		// Skip comment lines.
		if string(curLine[0]) == "*" {
			continue
		}
		
		// Split the line above into a slice of tokens using strings.Fields.
		token = strings.Fields(curLine) 
		numTokens = len(token)
		
		// Skip blank lines.
		if numTokens == 0 {
			continue
		}

		// Take the appropriate action for a new keyword ---------------------------

		switch strings.ToUpper(token[0]) {

		case "NAME":
			if numTokens == 1 {
				Name = "NoName"
			} else {
				Name = token[1]
			}
			readState = 0
			continue

		case "ROWS":
			readState = 1
			continue

		case "COLUMNS":
			readState = 2
			continue

		case "RHS":
			// Switches readState only if RHS is the only keyword on the line. 
			// This allows for the use of a RHS set named "RHS" or "rhs" or alternatives.
			if len(token) == 1 {
				readState = 3
				continue
			}

		case "BOUNDS":
			// Switches readState only if BOUNDS is the only keyword on the line. 
			// This allows for the use of a BOUNDS set named "BOUNDS" or "bounds" 
			// or alternatives.
			if len(token) == 1 {
				readState = 4
				continue
			}

		case "RANGES":			
			readState = 5
			
			// Skip over the line which only has the key word present.
			if numTokens < 2 {
				continue
			}


		case "ENDATA":
			log(pINFO, "ENDATA reached at line %d.\n", mpsLineNum)
			readState = 6
		} //end switch

		if readState == 6 {
			break // Do not read any more lines
		}

		if numTokens > 1 && token[1] == "'MARKER'" {
			if token[2] == "'INTORG'" {
				markAsInt = true
				continue
			}
			if token[2] == "'INTEND'" {
				markAsInt = false
				continue
			}
		}

		//---------------------------------------------------

		switch readState {

		case 1: // Reading row names
			tempRow.State = stateActive
			tempRow.Type = token[0]
			tempRow.Name = token[1]
			tempRow.RHSlo = 0.0
			tempRow.RHSup = 0.0
			if tempRow.Type == "L" {
				tempRow.RHSlo = -Plinfy
			}
			if tempRow.Type == "G" {
				tempRow.RHSup = Plinfy
			}
			Rows = append(Rows, tempRow)
			rowMap[tempRow.Name] = len(Rows) - 1

		case 2: // Reading column data
			tempCol.Name = token[0]
			if tempCol.Name != lastColName {
				// found a new column
				tempCol.State = stateActive
				tempCol.Type = "R"
				tempCol.BndUp = Plinfy // Initialize upper bound to plus infinity
				tempCol.BndLo = 0.0
				if markAsInt {
					tempCol.Type = "I"
				}
				//TODO: deal with other types, like binary
				Cols = append(Cols, tempCol)
				colMap[tempCol.Name] = len(Cols) - 1
			}
			lastColName = tempCol.Name
			numCols = len(Cols)
			
			_, found = rowMap[token[1]]
			if found {
				// Extract the coefficient value, row index, column index, and
				// assign them to the temporary element.
				ihold    = rowMap[token[1]]
				rhold, _ = strconv.ParseFloat(token[2], 64)
				
				tempElem.InRow = ihold
				tempElem.InCol = numCols - 1
				tempElem.Value = rhold
				
				// Update the row, column, and element lists. Take the length
				// of the element list BEFORE appending the current element to avoid
				// adjusting index by 1.
				Rows[ihold].HasElems = append(Rows[ihold].HasElems, len(Elems))
				Cols[numCols-1].HasElems = append(Cols[numCols-1].HasElems, len(Elems))
				Elems = append(Elems, tempElem)

			} else {
				log(pERR, "ERROR: Cannot find row label %s. Aborting at line %d.\n", token[1], mpsLineNum)
				return errors.Errorf("Cannot find row label %s at line %d", token[1], mpsLineNum)
			}

			// if there is a second element in the line, add it too
			if numTokens == 5 {
				_, found = rowMap[token[3]]
				if found {
					ihold    = rowMap[token[3]]
					rhold, _ = strconv.ParseFloat(token[4], 64)

					tempElem.InRow = ihold
					tempElem.InCol = numCols - 1
					tempElem.Value = rhold					
					// Update the row, column, and element lists. Take the length
					// of the element list BEFORE appending the current element to avoid
					// adjusting index by 1.
				
					Rows[ihold].HasElems = append(Rows[ihold].HasElems, len(Elems))
					Cols[numCols-1].HasElems = append(Cols[numCols-1].HasElems, len(Elems))
					Elems = append(Elems, tempElem)
					
				} else {
					log(pERR, "Error: cannot find row label %s. Aborting at line %d.\n", token[3], mpsLineNum)
					return errors.Errorf("Cannot find row label %s at line %d", token[3], mpsLineNum)
				}
			}

		case 3: // Reading RHS values. TODO: allow for multiple RHSs
			// Use only the first RHS
			if numRhs == 0 {
				numRhs++
				rhsName = token[0]
			}
			if token[0] != rhsName {
				continue
			} // ignore later RHSs

			_, found = rowMap[token[1]]
			if found {
				ihold = rowMap[token[1]]
			} else {
				log(pERR, "ERROR: Cannot find row label %s. Aborting at line %d.\n", token[1], mpsLineNum)
				return errors.Errorf("Cannot find row label %s at line %d", token[1], mpsLineNum)
			}

			realhold, _ = strconv.ParseFloat(token[2], 64)
			switch Rows[ihold].Type {
			case "G":
				Rows[ihold].RHSlo = realhold
				Rows[ihold].RHSup = Plinfy
			case "L":
				Rows[ihold].RHSlo = -Plinfy
				Rows[ihold].RHSup = realhold
			case "E", "N":
				Rows[ihold].RHSlo = realhold
				Rows[ihold].RHSup = realhold
			}
			// If a second RHS is listed on the line, then grab it too
			if numTokens == 5 {

				_, found = rowMap[token[3]]
				if found {
					ihold = rowMap[token[3]]
				} else {
					log(pERR, "ERROR: Cannot find row label %s. Aborting at line %d.\n", token[3], mpsLineNum)
					return errors.Errorf("Cannot find row label %s at line %d", token[3], mpsLineNum)
				}

				realhold, _ = strconv.ParseFloat(token[4], 64)
				switch Rows[ihold].Type {
				case "G":
					Rows[ihold].RHSlo = realhold
					Rows[ihold].RHSup = Plinfy
				case "L":
					Rows[ihold].RHSlo = -Plinfy
					Rows[ihold].RHSup = realhold
				case "E", "N":
					Rows[ihold].RHSlo = realhold
					Rows[ihold].RHSup = realhold
				}
			}

		case 4: // Reading bounds data. TODO: make it read multiple bounds sets
			if numBoundSets == 0 {
				// First bound set found
				numBoundSets++
				boundSetName = token[1]
				if token[0] == "FR" || token[0] == "PL" || token[0] == "MI" {
					if numTokens < 3 {
						log(pWARN, "WARNING: Too few tokens on file line %d. Bound set name likely missing.\n", mpsLineNum)
					}
				} else if numTokens < 4 {
					log(pWARN, "WARNING: Too few tokens on file line %d. Bound set name likely missing.\n", mpsLineNum)
				}
			}
			if token[0] == "FR" || token[0] == "PL" || token[0] == "MI" {
				if numTokens < 3 {
					log(pWARN, "WARNING: Too few tokens on file line %d. Bound set name likely missing.\n", mpsLineNum)
				}
			} else if numTokens < 4 {
				log(pWARN, "WARNING: Too few tokens on file line %d. Bound set name likely missing.\n", mpsLineNum)
			}

			if token[1] != boundSetName {
				continue
			} // read only the first bounds set

			_, found = colMap[token[2]]
			if found {
				ihold = colMap[token[2]]
			} else {
				log(pWARN, "WARNING: No match for column name on MPS line %d. Continuing...\n", mpsLineNum)
				continue
			}

			if token[0] != "FR" && token[0] != "PL" && token[0] != "MI" {
				realhold, _ = strconv.ParseFloat(token[3], 64)
			}
			switch token[0] {
			case "LO":
				Cols[ihold].BndLo = realhold
			case "UP":
				Cols[ihold].BndUp = realhold
			case "FX":
				Cols[ihold].BndLo = realhold
				Cols[ihold].BndUp = realhold
			case "FR":
				Cols[ihold].BndLo = -Plinfy
				Cols[ihold].BndUp = Plinfy
			case "MI":
				Cols[ihold].BndLo = -Plinfy
			case "PL":
				Cols[ihold].BndUp = Plinfy
			case "BV": // Binary variable
				Cols[ihold].Type = "I"
				Cols[ihold].BndLo = 0.0
				Cols[ihold].BndUp = 1.0
			case "LI": // Lower bounded integer variable
				Cols[ihold].Type = "I"
				Cols[ihold].BndLo = realhold
				Cols[ihold].BndUp = Plinfy
			case "UI": // Upper bounded integer variable
				Cols[ihold].Type = "I"
				Cols[ihold].BndLo = 0.0
				Cols[ihold].BndUp = realhold
			case "SC": // Semi-continuous variable
				log(pWARN, "WARNING: Only the continuous part of a semi-continuous variable is handled. Lower bound = 1.0.\n")
				Cols[ihold].BndLo = 1.0
				Cols[ihold].BndUp = realhold
			default:
				log(pERR, "ERROR: No match for bound type on MPS file line %d. Continuing...\n", mpsLineNum)
			}

		case 5:
			{ //Reading RANGES.

				// TODO: May need to change logic if we have multiple range names
				// in the same block, or potentially multiple blocks. Could this occur?			
				if numRanges == 0 {
					// First range set found
					numRanges++
					rangeName = token[0]
				}
				if token[0] != rangeName {
					continue
				} // read only the first range set

				_, found = rowMap[token[1]]
				if found {
					ihold = rowMap[token[1]]
				} else {
					log(pWARN, "WARNING: No match for row name on MPS line %d. Continuing...\n", mpsLineNum)
					continue
				}
				
				realhold, _ = strconv.ParseFloat(token[2], 64)
				realhold1 = realhold // The sign is needed for E type ranges
				if realhold < 0.0 {
					realhold = -realhold
				} // Absolute value is needed in some cases
				switch Rows[ihold].Type {
				case "G":
					Rows[ihold].RHSup = Rows[ihold].RHSlo + realhold
					Rows[ihold].Type = "R"
				case "L":
					Rows[ihold].RHSlo = Rows[ihold].RHSup - realhold
					Rows[ihold].Type = "R"
				case "E":
					if realhold1 > 0.0 {
						Rows[ihold].RHSup = Rows[ihold].RHSlo + realhold
					} else {
						Rows[ihold].RHSlo = Rows[ihold].RHSup - realhold
					}
					Rows[ihold].Type = "R"
				} // end of switch on row type

				// Grab second set of ranges if present.				
				if numTokens == 5 {

					_, found = rowMap[token[3]]
					if found {
						ihold = rowMap[token[3]]
					} else {
						log(pWARN, "WARNING: No match for row name on MPS line %d. Continuing...\n", mpsLineNum)
						continue
					}
					
					realhold, _ = strconv.ParseFloat(token[4], 64)
					realhold1 = realhold // The sign is needed for E type ranges
					if realhold < 0.0 {
						realhold = -realhold
					} // Absolute value is needed in some cases
					switch Rows[ihold].Type {
					case "G":
						Rows[ihold].RHSup = Rows[ihold].RHSlo + realhold
						Rows[ihold].Type = "R"
					case "L":
						Rows[ihold].RHSlo = Rows[ihold].RHSup - realhold
						Rows[ihold].Type = "R"
					case "E":
						if realhold1 > 0.0 {
							Rows[ihold].RHSup = Rows[ihold].RHSlo + realhold
						} else {
							Rows[ihold].RHSlo = Rows[ihold].RHSup - realhold
						}
						Rows[ihold].Type = "R"
					} // end of switch on row type
				} // end if second set present on same line
								
				
			} // end of switch on case 5
		} // end of switch on readState
	} // end for loop reading file


	// Adjust the model after information was read into the data structures.
	
	if err = AdjustModel(); err != nil {
		return errors.Wrap(err, "ReadMpsFile failed to adjust model") 
	}
	
	return nil
}

//==============================================================================

// WriteMpsFile takes the information contained in the Rows, Cols, and Elems global
// data structures and writes it, in MPS format, to the file specified. 
// If the file already exists, it will be OVERWRITTEN. 
// In case of failure, the function returns an error. 
func WriteMpsFile(fileName string) error {
	var firstRowName string         // first row name to print per line
	var rowName      string         // second row name to print per line
	var firstElVal   float64        // first RHS value to print per line
	var elVal        float64        // second RHS value to print per line
	var itemsToPrint int            // tracking 2 or 1 items per line to print
	var index, k     int            // holder for array index being processed
	var numRanges    int            // number of rows that are ranges ("R")
	var rhsName    string = "RHS1"  // dummy name for RHS section
	var rangeName  string = "RNG1"  // dummy name for RANGES section
	var boundsName string = "BND1"  // dummy name for bounds section
	var markBase   string = "MARK"  // base name for integer markers
	var markCount  int    = 0       // marker counter appended to base name
	var markName   string = ""      // dummy marker name
	var colType    string = "R"     // type of last COL line written
	var rowType    string           // row type being processed

	//Check whether the output file exists. If it exists, overwrite it.

	if _, err := os.Stat(fileName); err == nil {
		err = os.Remove(fileName)
		if err != nil {
			return errors.Wrap(err, "Failed to delete existing file")
		}
	}

	f, err := os.Create(fileName)
	if err != nil {
		return errors.Wrap(err, "Failed to create new file")
	}

 	defer f.Close()

	// For consistency, use only Fprintf for file and Printf for status.

	log(pINFO, "\nWriting problem %s to file %s.\n", Name, fileName)

	// Print the name of the problem.
	fmt.Fprintf(f, "%-13s %s\n", "NAME", Name)

	// Print the rows
	fmt.Fprintf(f, "%s\n", "ROWS")

	// Treat ranged rows as "less than", and provide difference in RANGES section.
	for i := 0; i < len(Rows); i++ {
		if Rows[i].Type == "R" {
			rowType = "L"
		} else {
			rowType = Rows[i].Type
		}
		
		fmt.Fprintf(f, "%2s  %s\n", rowType, Rows[i].Name)
	}

	//--------------------------------------------------------------------------
	// Print the columns, assuming 2 sets per line
	fmt.Fprintf(f, "%s\n", "COLUMNS")

	for i := 0; i < len(Cols); i++ {

		// Flag empty columns as an error because they do not get written to file
		// and should not be present in the model.
		if len(Cols[i].HasElems) == 0 {
			return errors.Errorf("WriteMpsFile detected empty column %s", Cols[i].Name)
		}
		
		itemsToPrint = 0
		firstRowName = ""
		firstElVal = 0.0
		rowName = ""
		elVal = 0.0

		// Print marker if switching to or from integer type

		if Cols[i].Type == "I" && colType == "R" {
			colType = "I"
			markCount++
			markName = fmt.Sprintf("%s%04d", markBase, markCount)
			fmt.Fprintf(f, "    %-9s %-9s %23s\n",
				markName, "'MARKER'", "'INTORG'")
		}

		if Cols[i].Type == "R" && colType == "I" {
			colType = "R"
			markCount++
			markName = fmt.Sprintf("%s%04d", markBase, markCount)
			fmt.Fprintf(f, "    %-9s %-9s %23s\n",
				markName, "'MARKER'", "'INTEND'")
		}

		// Search rows associated with this column
		for j := 0; j < len(Cols[i].HasElems); j = j + 2 {
			index        = Cols[i].HasElems[j]
			firstRowName = Rows[Elems[index].InRow].Name
			firstElVal   = Elems[index].Value
			itemsToPrint = 1
			
			// Advance counter, check if still valid for second set, and print
			// both.
			k = j + 1
			if k < len(Cols[i].HasElems) {
				index   = Cols[i].HasElems[k]
				rowName = Rows[Elems[index].InRow].Name
				elVal   = Elems[index].Value
				fmt.Fprintf(f, "    %-9s %-9s %12f   %-19s %12f\n",
					Cols[i].Name, firstRowName, firstElVal, rowName, elVal)
				itemsToPrint = 0
				
			} // End if processing second data pair to be printed

		} // End for rows associated with a column

		// There may be one more value pair to print, do it now
		if itemsToPrint == 1 {
			fmt.Fprintf(f, "    %-9s %-9s %12f\n",
				Cols[i].Name, firstRowName, firstElVal)
		} // End if last pair needs to be printed

	} // End for columns list

	//--------------------------------------------------------------------------
	// Print the RHS
	fmt.Fprintf(f, "%s\n", "RHS")

	itemsToPrint = 0
	firstRowName = ""
	firstElVal   = 0.0
	numRanges    = 0

	for i := 0; i < len(Rows); i++ {

		switch Rows[i].Type {
		case "G", "E", "N":
			rowName = Rows[i].Name
			elVal = Rows[i].RHSlo
			if elVal == 0 {
				continue
			}
			itemsToPrint++
			
		case "L":
			rowName = Rows[i].Name
			elVal = Rows[i].RHSup
			if elVal == 0 {
				continue
			}
			itemsToPrint++
		
		case "R":
			// Treat this as L with RHS set to RHSup and range value to (RHSup - RHSlo).
			numRanges++
			rowName = Rows[i].Name
			elVal = Rows[i].RHSup
			if elVal == 0 {
				continue
			}
			itemsToPrint++
				
			
		} // End switch on row type

		// If we found two values, we can print them. Otherwise
		// save values and print them with the next we may find.
		if itemsToPrint == 2 {
			fmt.Fprintf(f, "    %-9s %-9s %12f   %-19s %12f\n",
				rhsName, firstRowName, firstElVal, rowName, elVal)
			itemsToPrint = 0
		} else if itemsToPrint == 1 {
			// More items may be found, remember what we have so far
			firstRowName = rowName
			firstElVal = elVal
		} // End if we have 1 or 2 items to print

	} // End for Rows in RHS section

	// There may be one more value pair to print, do it now
	if itemsToPrint == 1 {
		fmt.Fprintf(f, "    %-9s %-9s %12f\n", rhsName, firstRowName, firstElVal)
	} // End if last pair needs to be printed

	//--------------------------------------------------------------------------
	// Print the ranges if any ranged row exist.

	if numRanges != 0 {
		
		fmt.Fprintf(f, "%s\n", "RANGES")

		itemsToPrint = 0
		firstRowName = ""
		firstElVal   = 0.0
	
		for i := 0; i < len(Rows); i++ {
			if Rows[i].Type != "R" {
				continue
			}			

			rowName = Rows[i].Name
			elVal   = Rows[i].RHSup - Rows[i].RHSlo
			if elVal == 0 {
				continue
			}
			itemsToPrint++

			// If we found two values, we can print them. Otherwise
			// save values and print them with the next we may find.
			if itemsToPrint == 2 {
				fmt.Fprintf(f, "    %-9s %-9s %12f   %-19s %12f\n",
					rangeName, firstRowName, firstElVal, rowName, elVal)
				itemsToPrint = 0
			} else if itemsToPrint == 1 {
				// More items may be found, remember what we have so far
				firstRowName = rowName
				firstElVal = elVal
			} // End if we have 1 or 2 items to print

			
		} // End for all rows in list
		
		// There may be one more value pair to print, do it now
		if itemsToPrint == 1 {
			fmt.Fprintf(f, "    %-9s %-9s %12f\n", rangeName, firstRowName, firstElVal)
		} // End if last pair needs to be printed
								
	} // End if ranged rows present

	//--------------------------------------------------------------------------
	// Print the bounds
	fmt.Fprintf(f, "%s\n", "BOUNDS")

	for i := 0; i < len(Cols); i++ {

		if Cols[i].BndLo == -Plinfy && Cols[i].BndUp == Plinfy {
			// Both bounds infinite, variable is free.
			fmt.Fprintf(f, " %2s %-9s %-9s\n",
				"FR", boundsName, Cols[i].Name)
			continue		
		} // End if free variable

		// log(pTRC, "  %s, LO = %f, UP = %f\n", Cols[i].Name, Cols[i].BndLo, Cols[i].BndUp)
		
		if Cols[i].BndLo == Cols[i].BndUp {
			// Both bounds same, variable is fixed.
			fmt.Fprintf(f, " %2s %-9s %-9s %12f\n",
				"FX", boundsName, Cols[i].Name, Cols[i].BndLo)
		} else {
			// Not fixed, so print one or both bounds.

			if  Cols[i].BndLo == 0 && Cols[i].BndUp == Plinfy {
				continue
			}
			
			if  Cols[i].BndLo == -Plinfy && Cols[i].BndUp == 0 {
				continue
			}

			if Cols[i].BndLo != 0 {
				fmt.Fprintf(f, " %2s %-9s %-9s %12f\n", "LO", boundsName, 
					Cols[i].Name, Cols[i].BndLo)				
			}

			if Cols[i].BndUp != Plinfy {
				fmt.Fprintf(f, " %2s %-9s %-9s %12f\n", "UP", boundsName, 
					Cols[i].Name, Cols[i].BndUp)				
			}		

		} // End else variable not fixed

	} // End of printing bounds loop

	// Print the end of data marker
	fmt.Fprintf(f, "%s\n", "ENDATA")

	log(pINFO, "Successfully wrote %d rows and %d cols to file.\n", len(Rows), len(Cols))
	return nil
}

//============================ END OF FILE =====================================