//==============================================================================
// ifcoin: Interface Functions for Coin-OR
// 01   July  29, 2018   File created
// 02   Aug.  28, 2018   Modified lporun, added support for Coin-OR


// This file contains functions needed if Coin-OR is used to solve the model.
// The functions and data structures are independent of other lpo components.
// Optionally, this file may be excluded from the build if Coin-OR is not being
// used and it is important to reduce compilation time or the size of the executable.
//
// The primary function is CoinSolveProb, which in turn calls other functions 
// to read, reduce, and solve the model and process the solution.

package lpo

import (
	"bufio"
	"encoding/xml"
	"fmt"
	"github.com/pkg/errors"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"time"
)

// The "Coin" data types define the XML data structures for parsing the output 
// generated by Coin-OR. They are defined to match the logical blocks of data 
// contained in the output. 
//
// CoinSoln is the main structure containing the results generated by Coin-OR.
// It is returned by functions which generate or process the Coin-OR output.
type CoinSoln struct {
    ProbName   string         `xml:"general>instanceName"`
	Solver     string         `xml:"general>solverInvoked"`
	ObjVal     float64        `xml:"optimization>solution>objectives>values>obj"`
	Varb     []CoinResVarb    `xml:"optimization>solution>variables>values>var"`
	RedCost  []CoinResRcost   `xml:"optimization>solution>variables>other>var"`
	Dual     []CoinResConDual `xml:"optimization>solution>constraints>dualValues>con"`
}

// Constraint dual values for the Coin-OR solution.
type CoinResConDual struct {
	Index  int     `xml:"idx,attr"`
	Value  float64 `xml:",chardata"`
}

// Variable values for the Coin-OR solution.
type CoinResVarb struct {
	Index       int     `xml:"idx,attr"`
	Value       float64 `xml:",chardata"`
}

// Variable reduced costs for the Coin-OR solution.
type CoinResRcost struct {
	Index       int     `xml:"idx,attr"`
	Value       float64 `xml:",chardata"`
}


// Package variable defining the location of the OSSolverService executable used
// in solving problems via Coin-OR. This directory that contains the OsSolverService
// must also contain clp.exe and cbc.exe.
var coinOrExe string = "C:/coin_dir/OSSolverService"

// Package variable used internally by the keepAlive concurrent routine to shut
// itself down and allow the main program to continue once it is halted.
var stopRunning bool  // flag telling keepAlive function to stop running

//==============================================================================
// GENERAL UTILITY PRIVATE FUNCTIONS
//==============================================================================

// coinInitSoln initializes the data structure used for storing the solution
// obtained by parsing the xml solution file produced by Coin-OR, and passes the
// initialized structure as the soln argument back to the caller.
// In case of failure, function returns an error.
func coinInitSoln(soln *CoinSoln) error {

	soln.ProbName   = ""
	soln.Solver     = ""
	soln.ObjVal     = 0.0
	soln.Varb       = nil
	soln.RedCost    = nil
	soln.Dual       = nil

	return nil
}

//==============================================================================

// buildCnConMap returns the map of constraints built from the Coin-OR output.
// In case of failure, function returns an error.
func buildCnConMap(cnSoln CoinSoln, constrMap *PsResConMap) error {
	var index   int     // index of array item being processed

	newMap := make(PsResConMap)	

	// KLUDGE ALERT:
	// The constraint name is not provided in the solution, so we must extract it
	// from the original Rows list, which is a global variable.	This is risky,
	// since it assumes that the order of the original Rows list is the SAME
	// (except for the objective function) as the dual list provided by Coin-OR.

	index = 0		
	for i := 0; i < len(cnSoln.Dual); i++ {

		if index == ObjRow {
			// Exclude the row that contains the objective function from the names.
			index++
		}	
			
		mapItem := newMap[Rows[index].Name]

		// Transfer values received from Coin-OR. Of these, only the dual is provided
		// in the xml file.		
		mapItem.Status = psVarStatNA
		mapItem.Slack  = 0
		mapItem.Pi     = 0
		mapItem.Dual   = cnSoln.Dual[i].Value

		// Initialize all other values that we may fill in later
		mapItem.Rhs    = 0
		mapItem.Type   = "X"
		
		newMap[Rows[index].Name] = mapItem
		index++
	}

	*constrMap = newMap	

	return nil
}

//==============================================================================

// buildCnVarMap returns the map of variables built from the solver output. 
// In case of failure, it returns an error.
func buildCnVarMap(scaleMap map[string]float64, cnSoln CoinSoln, varbMap *PsResVarMap) error {
	
	newMap := make(PsResVarMap)	

	// KLUDGE ALERT:
	// The Coin-OR xml solution file does not contain variable names. We must get
	// these from the global Cols data structure. This assumes that the order of
	// the Cols list is the same as the order of the results returned by Coin-OR.
	// If the list lengths differ, exit with an error.
	
	if len(Cols) != len(cnSoln.Varb) {
		return errors.Errorf("Solution has %d variables, expected %d", 
			len(cnSoln.Varb), len(Cols))					
	}
			
	for i := 0; i < len(Cols); i++ {		

		scaleFactor, ok := scaleMap[Cols[i].Name];
		if !ok {
			return errors.Errorf("Missing scale factor for variable %s", Cols[i].Name)			
		}

		mapItem := newMap[Cols[i].Name]
		mapItem.Value       = cnSoln.Varb[i].Value
		mapItem.ScaleFactor = scaleFactor
		mapItem.Status      = psVarStatNA

		if len(cnSoln.RedCost) > 0 {
			mapItem.ReducedCost = cnSoln.RedCost[i].Value			
		} else {
			mapItem.ReducedCost = 0						
		}
					
		newMap[Cols[i].Name] = mapItem
	} // End for processing varbs list

	*varbMap = newMap
		
	return nil	
}

//==============================================================================

// stripMpsFile removes any empty lines or lines which start with an asterisk
// (comments) found in the srcFile and writes whatever is left in the same order
// to destFile.
// In case of failure, function returns an error.
func stripMpsFile(srcFile string, destFile string) error {
	var mpsLineNum     int = 0  // line number of MPS file being read
	var err              error  // error value received from secondary function 

	// Check so we don't accidentally overwrite the original file.	
	if srcFile == destFile {
		return errors.Wrap(err, "Source and destination files must be different")		
	}
	
	// Check that the input file exists and open it for reading, and defer closing it.
	inFile, err := os.Open(srcFile)
	if err != nil {
		return errors.Wrap(err, "Open MPS source file failed")
	}
	defer inFile.Close()

	//Check whether the file exists. If it exists, overwrite it.
	if _, err := os.Stat(destFile); err == nil {
		err = os.Remove(destFile)
		if err != nil {
			return errors.Wrapf(err, "Failed to delete existing file %s", destFile)
		}
	}

	// Create destination file and defer closing it.	
	outFile, err := os.Create(destFile)
	if err != nil {
		return errors.Wrapf(err, "Failed to create destination file %s", destFile)
	}
 	defer outFile.Close()

	mpsReader := bufio.NewReader(inFile)

	// Create the token which will be used when reading the file.
	token := make([]string, 1)

	// Infinite loop reading file until EOF is reached.
	for {
		mpsLineNum++

		// Read one line at a time. Exit loop when end of file is reached.
		curLine, err := mpsReader.ReadString('\n')

		if err == io.EOF {
			break
		}
		if err != nil {
			return errors.Errorf("Problem reading line %d", mpsLineNum)
		}

		// Skip lines with an asterisk in the first column (comments).
		if string(curLine[0]) == "*" {
			continue
		} 
		
		// Split the line above into a slice of tokens using strings.Fields.
		// Skip blank lines.
		token = strings.Fields(curLine) 

		if len(token) == 0 {
			continue
		}

		// Found a non-blank, non-comment line, write it to the destination file.
		fmt.Fprintln(outFile, curLine)	
	}	

	return nil	
}

//==============================================================================

// keepAlive is a function which prints the elapsed time concurrently while Coin-OR
// is working on solving the MILP. When the calling function is done, it signals
// the keepAlive function to exit and allow the caller to continue.
// Function periodically polls the stopRunning package global variable, and sends
// a signal via the dch channel to the caller to notify it that keepAlive is exiting.
func keepAlive(dch chan int) {
	var startTime  time.Time      // time at which function started running
	var duration   time.Duration  // time elapsed since function started
	var pollInt    time.Duration  // polling interval in seconds

	// Set the start time and polling interval. Wait a short interval before
	// starting infinite loop in case problem is solved very quickly and we need
	// not wait for an entire polling cycle.
	startTime = time.Now()
	pollInt   = 5
	time.Sleep(1 * time.Second)

	// Infinite loop which exits when stopRunning variable is set to true.
	// While running, function prints the elapsed time. 	
	for {
		if stopRunning {
			// Calling routine will tell us when to stop.
			break
		}
		
		duration = time.Since(startTime)
		log(pINFO, "\r  ... processing duration %.0f seconds", duration.Seconds())
		time.Sleep(pollInt * time.Second)
	}
	
	// Calling routine ready, send signal we are stopping so it can resume.	
	dch <- 1	
}

//==============================================================================
// GENERAL UTILITY EXPORTED FUNCTIONS
//==============================================================================


// CoinSolveMps uses Coin-OR to solve the problem defined in the MPS file specified.
// The function accepts as input the full path of the MPS file defining the model
// to be processed, location of the file to which the solution should be written, 
// the solver to be used (CLP or CBC), and the data structure in which the solution
// is passed back to the caller. 
//
// The function generates a command file, and instructs Coin-OR to run it. 
// Once complete, the xml output file generated by the solver is parsed and
// the results are passed back to the caller via the soln variable.
// 
// In case of failure, function returns an error.
//
//	The arguments used by this function are as follows:
//	   mpsFile  [input]: name of MPS file which defines the model
//	   solnFile [input]: name of xml file where solution is written
//	   solver   [input]: solver to be used (CLP for LP or CBC for MILP)
//	   soln    [output]: data structure in which parsed solution is returned  
func CoinSolveMps(mpsFile string, solnFile string, solver string, soln *CoinSoln) error {
	var coinCmdFile string   // command file telling Coin-OR what to do
	var tmpMpsFile  string   // MPS file stripped of comments and blank lines
	var err           error  // error returned by secondary functions called

	// Initialize the solution set which may need to be returned if errors occur
	// before any parsing takes place.

	coinCmdFile = tempDirPath + "/coinCommands.txt"
	tmpMpsFile  = tempDirPath + "/tmpMpsIn.txt"
		
	// Check whether the output file exists.
	if _, err = os.Stat(solnFile); err == nil {
		//if it does exist, remove it
		if err = os.Remove(solnFile); err != nil {
			return errors.Wrap(err, "CoinSolveMps failed to remove solution file")
		}
	}

	// Create the command file.
	f, err := os.Create(coinCmdFile)
	defer f.Close()

	if err != nil {
		return errors.Wrap(err, "CoinSolveMps failed to create command file")
	} 

	// Coin-OR can't handle comments or blank lines in MPS, so strip them out.
	if err = stripMpsFile(mpsFile, tmpMpsFile); err != nil {
		return errors.Wrap(err, "CoinSolveMps failed to strip comments from MPS file")
	}
	
	fmt.Fprintln(f, "-mps ", tmpMpsFile)    // command to read the MPS file
	fmt.Fprintln(f, "-osrl ", solnFile)     // command to save xml output file

	if solver == "CLP" {
		fmt.Fprintln(f, "-solver clp")      // use clp to solve as LP		
	} else if solver == "CBC"{
		fmt.Fprintln(f, "-solver cbc")      // use cbc to solve as MIP				
	} else {
		return errors.Wrapf(err, "CoinSolveMps received unsupported solver '%s'", solver)		
	}
	
	args := []string{"-config", coinCmdFile}
	_, err = exec.Command(coinOrExe, args...).Output()

	if err != nil {
		return errors.Wrap(err, "Exec command for CoinOR failed in CoinSolveMps")
	}

	// Now parse the solution. The parser initializes the data structure and
	// there is no longer need to initialize global variables.

	err = CoinParseSoln(solnFile, soln)
	if err != nil {
		return errors.Wrap(err, "CoinSolveMps failed")
	}
		
	return nil
}



//==============================================================================

// CoinParseSoln takes as input the location of the file storing the raw
// output generated by Coin, parses it, and returns the parsed solution to
// the caller in the soln variable. 
// In case of failure, function returns an error.
func CoinParseSoln(fileName string, soln *CoinSoln) error {
	var err error  // error returned by called functions

	// Initialize the solution data structure.	 
	_ = coinInitSoln(soln)

 	log(pINFO, "\nProcessing solution file %s\n", fileName)
	
	// Open the file containing the Coin xml output, and defer closing this file.	
	solnFile, err := os.Open(fileName)
	if err != nil {
		return errors.Wrap(err, "Unable to open Coin solution file")
	}
	defer solnFile.Close()

	// Parse the xml file and populate the data structure with the results.	
	XMLdata, err := ioutil.ReadAll(solnFile)
	if err != nil {
		return errors.Wrap(err, "Unable to parse coin solution file")
	}

	xml.Unmarshal(XMLdata, soln)

	return nil
}

//==============================================================================

// CoinSolveProb receives a control structure specifying the MPS input file to be read,
// the file where the solution should be written (default will be used if not
// specified), the maximum number of iterations lpo should perform, and boolean
// flags indicating which reduction operations to perform and whether to solve
// the problem.
//
// The function then reads the MPS input file and reduces the problem size by
// iteratively performing the reduction operations specified. If the RunSolver 
// flag is set to false, the function returns at this point.
//
// If the RunSolver flag is set to true, the function then passes the reduced 
// model to be solved either as an LP using by Coin-OR CLP, or as a MIP using CBC. 
// CoinSolveProb then processes the results provided by the solver and, 
// in conjunction with data stored in internal structures about the presolve 
// operations, reconstitues the original problem, and returns the result in the 
// psRslt data structure. 
//
// In case of failure, function returns an error.
func CoinSolveProb (psc PsCtrl, psRslt *PsSoln) error {
	var numRows            int  // number of rows in the model prior to reduction
	var numCols            int  // number of cols in the model prior to reduction
	var numElem            int  // number of elements in the model prior to reduction
	var coefPerLine        int  // number of coef./line to be printed by WritePsopFile
	var fileCoinIn      string  // MPS file for input to Coin-OR
	var fileCoinOut     string  // xml file for Coin-OR output
	var cnSoln        CoinSoln  // Coin-OR solution from parsed xml file
	var conMap     PsResConMap  // constraint map merged from Cplex and reduction results
	var varMap     PsResVarMap  // variable map  merged from Cplex and reduction results
	var origObjFunc      psRow  // objective function before reductions in post-solve format
	var psRows         []psRow  // original constraints translated to post-solve format
	var err              error  // error returned by secondary functions called
	var colScaleMap  map[string]float64  // map of column scale factors in original model

	// Initialize variables.
	psOpList       = nil
	psRslt.ObjVal  = 0
	psRslt.ConMap  = nil
	psRslt.VarMap  = nil
	psRslt.RowsDel = 0
	psRslt.ColsDel = 0
	psRslt.ElemDel = 0
	coefPerLine    = 2

	if psc.FileInMps != "" {
		if err = ReadMpsFile(psc.FileInMps); err != nil {
			return errors.Wrap(err, "CoinSolveProb failed to read file")
		}
		
		// Check that none of the other files have the same name so we don't
		// accidentally overwrite our input file.
		
		if psc.FileInMps == psc.FileOutSoln {
			return errors.Errorf("Solver solution file cannot overwrite %s", psc.FileInMps)
		}
		
		if psc.FileInMps == psc.FileOutMpsRdcd {
			return errors.Errorf("MPS output file cannot overwrite %s", psc.FileInMps)
		}

		if psc.FileInMps == psc.FileOutPsop {
			return errors.Errorf("PSOP output file cannot overwrite %s", psc.FileInMps)
		}
		
	} // End if populating model from file

	// Record original matrix size.
	numRows = len(Rows)
	numCols = len(Cols)
	numElem = len(Elems)

	// If lists of rows, cols, or elems is empty, return an error.
	
	if numRows <= 0 {
		return errors.Errorf("CoinSolveProb received empty rows list")	
	}
	if numCols <= 0 {
		return errors.Errorf("CoinSolveProb received empty columns list")	
	}
	if numElem <= 0 {
		return errors.Errorf("CoinSolveProb received empty elements list")	
	}

		
	// Translate all original rows to the new format and save the objective function,
	// if it exists, as a separate entity also in the new format.
	
	_ = translateAllRows(&psRows)
	
	if ObjRow >= 0 {
		// If objective function is not the first row in the list, move it there.
		if ObjRow != 0 {
			log(pINFO, "\nMoving %s from index %d to top of list.\n", Rows[ObjRow].Name, ObjRow)
			_ = swapRows(0, ObjRow)
			ObjRow = 0	
		}

		// There is an objective function, save it for later use.
		if err = translateRow(Rows[ObjRow], &origObjFunc); err != nil {
			return errors.Wrap(err, "CoinSolveProb failed")
		}
	}	

	// Make the map of column scale factors and populate map until the values
	// can be transferred to the Cplex solution.

	colScaleMap = make(map[string]float64)
	
	for i := 0; i < len(Cols); i++ {
		colScaleMap[Cols[i].Name] = Cols[i].ScaleFactor	
	}

	// Remove rows and columns specified in the control structure and calculate
	// how many rows, cols, and elems were removed.			
	if err = ReduceMatrix(psc); err != nil {
		return errors.Wrap(err, "CoinSolveProb failed")
	}
	
	psRslt.RowsDel = numRows - len(Rows)
	psRslt.ColsDel = numCols - len(Cols)
	psRslt.ElemDel = numElem - len(Elems)


	// Write the reduced MPS file either to a location specified by the user, or
	// to a temporary file which will be read by Coin-OR.	
	if psc.FileOutMpsRdcd != "" {
		fileCoinIn = psc.FileOutMpsRdcd
	} else {
		fileCoinIn = tempDirPath + "/CoinMpsIn.txt"
	}

	if err = WriteMpsFile(fileCoinIn); err != nil {
		return errors.Wrap(err, "CoinSolveProb failed")		
	}		

	// Write the Psop file if requested.
	if psc.FileOutPsop != "" {
		if err = WritePsopFile(psc.FileOutPsop, coefPerLine); err != nil {
			return errors.Wrap(err, "CoinSolveProb failed")		
		}				
	}

	// Solution was not requested, so return at this point
	if ! psc.RunSolver {
		return nil		
	}

	// Set the file name for the xml solution, either to name specified by user,
	// or to a temporary file.
	
	// Write the solution to xml file if requested.
	if psc.FileOutSoln != "" {
		fileCoinOut = psc.FileOutSoln
	} else {
		fileCoinOut = tempDirPath + "/CoinSolnOut.txt"
	}
		
	// Solve problem using Coin-OR CLP (for LP) or CBC (for MIP) solver.

	if isMip() {
		// MIP case

		if logLevel > pNONE {
			// Since Coin-OR cbc produces no output and takes a long time to finish,
			// launch a concurrent keepAlive function to indicate we are still running.
			// Only do this if user expects to see some output.
					
			log(pINFO, "\nSolving MILP...\n")
			dch  := make(chan int)
			stopRunning = false

			go keepAlive(dch)

			err = CoinSolveMps(fileCoinIn, fileCoinOut, "CBC", &cnSoln)
			stopRunning = true
			<- dch
			
		} else {
			// No output expected, don't launch keepAlive.
			err = CoinSolveMps(fileCoinIn, fileCoinOut, "CBC", &cnSoln)			
		}

		// If the solution failed, return with error.
		if err != nil {
			return errors.Wrap(err, "CoinSolveProb failed")
		}
								
	} else {
		// LP case
		
		if err = CoinSolveMps(fileCoinIn, fileCoinOut, "CLP", &cnSoln); err != nil {
			return errors.Wrap(err, "CoinSolveProb failed")
		}		
	}

/*	
	// Parse the solution file.
	if err = CoinParseSoln(fileCoinOut, &cnSoln); err != nil {
		return errors.Wrap(err, "CoinSolveProb failed")		
	}

*/

	// Build the variable and constraint maps, transfer data from original model
	// and merge with results obtained from Coin-OR.	

	_ = buildCnConMap(cnSoln, &conMap)

	if err = buildCnVarMap(colScaleMap, cnSoln, &varMap); err != nil {
		return errors.Wrap(err, "CoinSolveProb failed to process variables")				
	}

	psRslt.ConMap = conMap
	psRslt.VarMap = varMap
	

	
	// Update the maps with the information deleted during presolve.
	if err = postSolve(psRslt.ConMap, psRslt.VarMap); err != nil {
		return errors.Wrap(err, "CoinSolveProb failed")
	}

	// Restore all other rows that may have been removed and not put back during
	// pre- and postsolve (e.g. non-binding).

	for i := 0; i < len(psRows); i++ {
		_ = addConMapItem(psRslt.ConMap, psRows[i])
	}

	for i := 0; i < len(psRows); i++ {
				
		if mapItem, ok := psRslt.ConMap[psRows[i].Name]; ok {

			mapItem.Dual        = psRslt.ConMap[psRows[i].Name].Dual
			mapItem.Rhs         = psRslt.ConMap[psRows[i].Name].Rhs
			mapItem.Slack       = psRslt.ConMap[psRows[i].Name].Slack 
			mapItem.Status      = psRslt.ConMap[psRows[i].Name].Status
			mapItem.Type        = psRslt.ConMap[psRows[i].Name].Type
			mapItem.ScaleFactor = psRslt.ConMap[psRows[i].Name].ScaleFactor
			psRslt.ConMap[psRows[i].Name] = mapItem
		} else {
			log(pERR, "ERROR: Row %s not found in map.\n", psRows[i].Name)
		}
	}
	 	
	// Calculate the proper value of the objective function.
    // There may have been a constant associated with the objective function 
	// which must now be included in the calculation.
	
	if err = getPstLhs(origObjFunc, psRslt.VarMap, &psRslt.ObjVal); err != nil {
		return errors.Wrap(err, "CoinSolveProb failed")		
	}

	// Adjust the objective function by the constant value.
	psRslt.ObjVal -= objRowConst

	return nil
}

//============================ END OF FILE =====================================
